# -*- coding: utf-8 -*-
"""RNN_Algotrade.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W4oJTA3VJzW37e0ILbquWqZbhDRZGelE
"""

from pandas import read_csv
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, SimpleRNN, InputLayer
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import math
import matplotlib.pyplot as plt

from pyalgotrade import strategy, plotter
from pyalgotrade.barfeed import quandlfeed
from pyalgotrade.technical import ma, rsi, macd, bollinger

from pyalgotrade.bar import Frequency
from pyalgotrade.barfeed.csvfeed import GenericBarFeed

from strategies import *

import sys
import pandas as pd

max_spend = 0.25
window_size = 10
total_cash = 10000

n_models = 7

hidden_units = 2
dense_units = 3

use_ind_values = True

class RNNStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, model, smaPeriod=15, max_spend=0.25, fastEmaPeriod=12, slowEmaPeriod=26, signalEmaPeriod=9, bBandsPeriod=1, isTest=False, verbose=False):
        super(RNNStrategy, self).__init__(feed, 10000)
        self.__instrument = instrument
        self.__model = model

        self.__onBars = [sma_onBars, rsi_onBars, smarsi_onBars, macd_onBars, cbasis_onBars, gfill_onBars, history_onBars]
        self.__cbasis = 0

        assert n_models == len(self.__onBars)

        self.__lastTop, self.__lastBottom, self.__trend, self.__trendLength = None, None, 0, 0
        self.__portValues, self.__cprices, self.__shareValues = [], [], []
        self.__maxSpend = max_spend

        self.__sma = ma.SMA(feed[instrument].getPriceDataSeries(), smaPeriod)
        self.__rsi = rsi.RSI(feed[instrument].getPriceDataSeries(), smaPeriod)
        self.__macd = macd.MACD(feed[instrument].getPriceDataSeries(), fastEmaPeriod, slowEmaPeriod, signalEmaPeriod)
        self.__bb = bollinger.BollingerBands(feed[instrument].getPriceDataSeries(), bBandsPeriod, 2)

        self.__verbose = verbose
        self.__isTest = isTest

        self.__indValues = []
        self.__window = np.array([])

    def get_instrument(self):
        return self.__instrument

    def get_sma(self):
        return self.__sma

    def get_rsi(self):
        return self.__rsi

    def get_macd(self):
        return self.__macd

    def get_bb(self):
        return self.__bb

    def get_cbasis(self):
        return self.__cbasis

    def get_port_values(self):
        return self.__portValues

    def get_cprices(self):
        return self.__cprices

    def get_share_values(self):
        return self.__shareValues

    def get_last_top(self):
        return self.__lastTop

    def get_last_bottom(self):
        return self.__lastBottom

    def get_trend(self):
        return self.__trend

    def get_trend_length(self):
        return self.__trendLength

    def get_ind_values(self):
        return np.array(self.__indValues)

    def set_last_top(self, lt):
        self.__lastTop = lt

    def set_last_bottom(self, lb):
        self.__lastBottom = lb

    def set_trend(self, t):
        self.__trend = t

    def set_trend_length(self, tl):
        self.__trendLength = tl
  
    def onBars(self, bars):
        n_shares = self.getBroker().getShares(self.__instrument)
        bar = bars[self.__instrument]
        c_price = bar.getPrice()
        strat_cash = self.getBroker().getCash(False)

        pd_ind_values = np.array([onBars(self, bars) for onBars in self.__onBars])
        self.__indValues.append(pd_ind_values)

        if self.__isTest:
            return

        delta_shares = 0
        if use_ind_values:
            pd_ind_values = np.reshape(pd_ind_values, (1, n_models, 1))
            #print(pd_ind_values)
            res = self.__model.predict(pd_ind_values)
            #print(res)
            delta_shares = int(total_cash*max_spend*res)
        else:
            self.__window = np.append(self.__window, c_price)
            if len(self.__window) > window_size:
                x = np.reshape(np.array([(self.__window[i+1] - self.__window[i]) / self.__window[i] for i in range(len(self.__window)-1)]),(1, window_size, 1))
                #print(x)
                res = self.__model.predict(x)
                print(res)
                delta_shares = int(total_cash*max_spend*res)
                self.__window = np.delete(self.__window, 0)
            else:
                delta_shares = 0
        
        if delta_shares + n_shares < 0:
            delta_shares = -n_shares

        if delta_shares > 0 and strat_cash < delta_shares*c_price:
            delta_shares = int(strat_cash/c_price)
        
        print("Day ",len(self.__portValues),": have",n_shares,"shares and $",strat_cash, end="")
        if delta_shares > 0:
            print(", buying",delta_shares,"shares at $",c_price)
        elif delta_shares < 0:
            print(", selling",abs(delta_shares),"shares at $",c_price)
        else:
            print("")
        
        if not delta_shares == 0:
            self.marketOrder(self.__instrument, delta_shares)
            self.__cbasis = (n_shares*self.__cbasis + delta_shares*c_price) / (n_shares + delta_shares) if not n_shares + delta_shares == 0 else 0
        self.__portValues.append(self.getBroker().getEquity())
        self.__cprices.append(c_price)
        self.__shareValues.append(n_shares*c_price)

# TODO adapt for indicator inputs instead
# TODO implement longer-term results (>1 trading interval)
def csv_to_xy(path):
    csv_df = pd.read_csv(path)
    cprices = list(csv_df["Close"])
    
    pct_adj = 0.1
    pct_chgs = [(cprices[i+1]-cprices[i]) / (cprices[i] * pct_adj) for i in range(len(cprices)-1)]

    # use percent changes in a given window as input x
    X_train = np.reshape(np.array([np.array(pct_chgs[i:i+window_size]) for i in range(len(cprices)-window_size-1)]), (len(cprices)-window_size-1,10))

    # use percent change in next interval as output y
    y_train = np.array(pct_chgs)
    mn,mx = min(y_train), max(y_train)
    norm_y_train = np.array([2*((x-mn)/(mx-mn))-1 for x in y_train])

    return X_train, y_train, norm_y_train

def main(stock=None, period=None, interval=""):
    # Load the bar feed from the CSV file
    if stock is None or period is None:
        stock = sys.argv[1].lower()
        period = sys.argv[2].lower() if len(sys.argv) >= 3 else "1y"
        interval = sys.argv[3].lower() if len(sys.argv) >= 4 else ""

    # TODO segment into testing and training feeds
    path = ""
    if len(interval) == 0:
        path = "WIKI-%s-%s-yfinance.csv" % (stock.upper(), period.lower())
    else:
        path = "WIKI-%s-%s-%s-yfinance.csv" % (stock.upper(), period.lower(), interval.lower())

    model = Sequential()
    X_train, y_train, norm_y_train = csv_to_xy(path)

    feed = quandlfeed.Feed() if interval.lower() == "" else GenericBarFeed(Frequency.MINUTE)
    feed.addBarsFromCSV(stock, path)

    if use_ind_values:
        test_strat = RNNStrategy(feed, stock, None, isTest=True)
        test_strat.run()
        X_train = test_strat.get_ind_values()[1:]

        #model.add(SimpleRNN(hidden_units, input_shape=(n_models, 1), activation='linear'))
        model.add(InputLayer(input_shape=(n_models, 1)))
        model.add(Dense(units=dense_units, activation='linear'))
        model.compile(loss='mean_squared_error', optimizer='adam')
        model.summary()

        print(X_train, norm_y_train)

        model.fit(X_train, norm_y_train, epochs=10)

    else:
        # TODO train RNN outside strategy framework, then build strategy for testing side
        # TODO figure out how to use indicator values in training later on
        model.add(SimpleRNN(hidden_units, input_shape=(window_size, 1), activation='linear'))
        model.add(Dense(units=dense_units, activation='linear'))
        model.compile(loss='mean_squared_error', optimizer='adam')
        model.summary()

        norm_y_train = norm_y_train[window_size:]

        model.fit(X_train, norm_y_train, epochs=10)

    #print("Creating + running strategy")
    feed = quandlfeed.Feed() if interval.lower() == "" else GenericBarFeed(Frequency.MINUTE)
    feed.addBarsFromCSV(stock, path)

    strat = RNNStrategy(feed, stock, model, isTest=False)
    strat.run()

    final_port_value = strat.getBroker().getEquity()
    print("Final portfolio value: $%.2f" % final_port_value)

    plt.title(stock.upper()+" using RNN Strategy")
    plt.plot([i for i in range(len(strat.get_port_values()))], strat.get_port_values(), label="Port Value")
    plt.plot([i for i in range(len(strat.get_port_values()))], [p*int(total_cash/strat.get_cprices()[0]) for p in strat.get_cprices()], label="Adj Share Price")
    plt.plot([i for i in range(len(strat.get_port_values()))], strat.get_share_values(), label="Port Value in Shares")
    plt.legend()
    plt.show()

if __name__ == "__main__":
    main()